/**
 * CORRE√á√ïES ADICIONAIS - CACHE DE LOTES + ATUALIZA√á√ÉO P√ìS-EDI√á√ÉO
 * Corrige: duplica√ß√£o de lotes nos selects + atualiza√ß√£o da lista ap√≥s edi√ß√£o
 */

console.log('üîß COMBO-CORRECOES-ADICIONAIS.JS carregando...');

/**
 * LIMPAR CACHE DOS SELECTS DE LOTE - VERS√ÉO RIGOROSA
 */
function limparCacheSelectsLote() {
    console.log('üßπ Limpeza RIGOROSA dos selects de lote...');
    
    const selectsLote = [
        document.getElementById('paidTicketLote'),
        document.getElementById('freeTicketLote'),
        document.getElementById('comboTicketLote'),
        document.getElementById('editPaidTicketLote'),
        document.getElementById('editFreeTicketLote'),
        document.getElementById('editComboTicketLote')
    ];
    
    selectsLote.forEach(select => {
        if (select) {
            // Obter placeholder original
            const primeiraOpcao = select.querySelector('option:first-child');
            const placeholderText = primeiraOpcao ? primeiraOpcao.textContent : 'Selecione um lote';
            
            // LIMPEZA TOTAL - remover ALL options
            while (select.firstChild) {
                select.removeChild(select.firstChild);
            }
            
            // Recriar APENAS o placeholder
            const novaOpcao = document.createElement('option');
            novaOpcao.value = '';
            novaOpcao.textContent = placeholderText;
            select.appendChild(novaOpcao);
            
            // Adicionar flag para evitar m√∫ltiplos carregamentos
            select.setAttribute('data-cache-limpo', 'true');
            select.setAttribute('data-ultimo-carregamento', Date.now().toString());
            
            console.log(`‚úÖ Select ${select.id} TOTALMENTE limpo`);
        }
    });
}

/**
 * CARREGAR LOTES LIMPOS COM CONTROLE DE DUPLICA√á√ÉO
 */
async function carregarLotesLimpos() {
    console.log('üîÑ Carregando lotes com controle RIGOROSO de duplica√ß√£o...');
    
    const eventoId = new URLSearchParams(window.location.search).get('evento_id');
    
    if (!eventoId) {
        console.log('üìù Novo evento - sem lotes para carregar');
        return;
    }
    
    // Verificar se j√° existe um carregamento em andamento
    if (window.carregandoLotes) {
        console.log('‚ö†Ô∏è Carregamento j√° em andamento, ignorando...');
        return;
    }
    
    window.carregandoLotes = true;
    
    try {
        const response = await fetch('/produtor/ajax/wizard_evento.php', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `action=carregar_todos_lotes&evento_id=${eventoId}`
        });
        
        const textResponse = await response.text();
        console.log('üì° Resposta lotes:', textResponse.substring(0, 200) + '...');
        
        let data;
        try {
            data = JSON.parse(textResponse);
        } catch (parseError) {
            console.error('‚ùå Erro ao parsear JSON dos lotes:', parseError);
            return;
        }
        
        if (data.sucesso && data.lotes) {
            console.log(`üìã ${data.lotes.length} lotes encontrados para carregamento √öNICO`);
            
            // Aplicar lotes a todos os selects COM CONTROLE RIGOROSO
            const selectsLote = [
                document.getElementById('paidTicketLote'),
                document.getElementById('freeTicketLote'),
                document.getElementById('comboTicketLote'),
                document.getElementById('editPaidTicketLote'),
                document.getElementById('editFreeTicketLote'),
                document.getElementById('editComboTicketLote')
            ];
            
            selectsLote.forEach(select => {
                if (select) {
                    // VERIFICAR se j√° foi carregado recentemente
                    const ultimoCarregamento = select.getAttribute('data-ultimo-carregamento');
                    const agora = Date.now();
                    
                    if (ultimoCarregamento && (agora - parseInt(ultimoCarregamento)) < 1000) {
                        console.log(`‚ö†Ô∏è Select ${select.id} carregado recentemente, pulando...`);
                        return;
                    }
                    
                    // VERIFICAR se j√° tem mais de 1 op√ß√£o (placeholder + op√ß√µes)
                    if (select.options.length > 1) {
                        console.log(`‚ö†Ô∏è Select ${select.id} j√° tem op√ß√µes, limpando primeiro...`);
                        // Manter apenas placeholder
                        while (select.options.length > 1) {
                            select.removeChild(select.lastChild);
                        }
                    }
                    
                    // Adicionar lotes SEM DUPLICA√á√ÉO
                    const lotesUnicos = new Map();
                    data.lotes.forEach(lote => {
                        if (!lotesUnicos.has(lote.id)) {
                            lotesUnicos.set(lote.id, lote);
                        }
                    });
                    
                    let adicionados = 0;
                    lotesUnicos.forEach(lote => {
                        // VERIFICAR se op√ß√£o j√° existe
                        const jaExiste = Array.from(select.options).some(opt => opt.value === lote.id.toString());
                        
                        if (!jaExiste) {
                            const option = document.createElement('option');
                            option.value = lote.id;
                            option.textContent = lote.nome || `Lote ${lote.id}`;
                            select.appendChild(option);
                            adicionados++;
                        }
                    });
                    
                    // Marcar como carregado
                    select.setAttribute('data-ultimo-carregamento', agora.toString());
                    
                    console.log(`‚úÖ ${adicionados} lotes √∫nicos adicionados a ${select.id} (total: ${select.options.length - 1})`);
                }
            });
            
        } else {
            console.error('‚ùå Erro ao carregar lotes:', data.erro);
        }
        
    } catch (error) {
        console.error('‚ùå Erro ao carregar lotes:', error);
    } finally {
        window.carregandoLotes = false;
    }
}

/**
 * BLOQUEAR OUTRAS FUN√á√ïES QUE CARREGAM LOTES
 */
function bloquearFuncoesCarregamentoLotes() {
    console.log('üö´ Bloqueando outras fun√ß√µes que carregam lotes...');
    
    const funcoesParaBloquear = [
        'carregarLotesNoModalCombo',
        'carregarLotesNoModalEditCombo', 
        'populateLoteSelect',
        'loadLotes',
        'carregarLotes',
        'updateComboTicketDates',
        'updateEditComboTicketDates'
    ];
    
    funcoesParaBloquear.forEach(nomeFuncao => {
        if (typeof window[nomeFuncao] === 'function') {
            const funcaoOriginal = window[nomeFuncao];
            
            window[nomeFuncao] = function(...args) {
                console.log(`üö´ Fun√ß√£o ${nomeFuncao} BLOQUEADA para evitar duplica√ß√£o de lotes`);
                
                // Para updateComboTicketDates, executar apenas a parte de datas, n√£o carregar lotes
                if (nomeFuncao.includes('updateComboTicketDates') || nomeFuncao.includes('updateEditComboTicketDates')) {
                    console.log(`üìÖ Executando apenas atualiza√ß√£o de datas para ${nomeFuncao}`);
                    // Chamar fun√ß√£o original mas interromper carregamento de lotes
                    try {
                        return funcaoOriginal.apply(this, args);
                    } catch (e) {
                        console.log(`‚ö†Ô∏è Erro controlado em ${nomeFuncao}:`, e.message);
                    }
                }
                
                return false; // Bloquear outras fun√ß√µes
            };
            
            console.log(`üö´ ${nomeFuncao} bloqueada`);
        }
    });
    
    console.log('‚úÖ Fun√ß√µes de carregamento de lotes bloqueadas');
}

/**
 * INTERCEPTAR ABERTURA DE MODAIS PARA LIMPAR CACHE - VERS√ÉO RIGOROSA
 */
function interceptarAberturaDosModais() {
    console.log('üéØ Configurando intercepta√ß√£o RIGOROSA para limpeza de cache...');
    
    // Lista de fun√ß√µes que abrem modais
    const funcoesModalOriginais = {};
    
    [
        'openPaidTicketModal', 'abrirModalPago',
        'openFreeTicketModal', 'abrirModalGratuito', 
        'openComboTicketModal', 'abrirModalCombo',
        'editComboTicket', 'editTicket', 'openModal'
    ].forEach(nomeFuncao => {
        if (typeof window[nomeFuncao] === 'function') {
            funcoesModalOriginais[nomeFuncao] = window[nomeFuncao];
            
            window[nomeFuncao] = function(...args) {
                console.log(`üéØ Interceptando ${nomeFuncao} - limpeza RIGOROSA`);
                
                // LIMPEZA IMEDIATA E AGRESSIVA
                limparCacheSelectsLote();
                
                // Executar fun√ß√£o original
                const resultado = funcoesModalOriginais[nomeFuncao].apply(this, args);
                
                // Carregar lotes com delay √öNICO
                setTimeout(() => {
                    if (!window.carregandoLotes) {
                        carregarLotesLimpos();
                    }
                }, 200);
                
                return resultado;
            };
            
            console.log(`‚úÖ ${nomeFuncao} interceptada para limpeza RIGOROSA`);
        }
    });
    
    // Interceptar cliques em bot√µes que abrem modais - MAIS AGRESSIVO
    setTimeout(() => {
        const botoes = document.querySelectorAll('button, .btn, [onclick]');
        botoes.forEach(botao => {
            const onclick = botao.onclick?.toString() || botao.getAttribute('onclick') || '';
            const texto = botao.textContent || botao.innerText || '';
            
            if (onclick.includes('Modal') || onclick.includes('modal') || 
                onclick.includes('editTicket') || onclick.includes('editCombo') ||
                texto.toLowerCase().includes('ingresso') || texto.toLowerCase().includes('combo')) {
                
                botao.addEventListener('click', () => {
                    console.log('üéØ Bot√£o interceptado - limpeza IMEDIATA');
                    
                    // Limpeza IMEDIATA
                    limparCacheSelectsLote();
                    
                    // Carregar com delay
                    setTimeout(() => {
                        if (!window.carregandoLotes) {
                            carregarLotesLimpos();
                        }
                    }, 300);
                }, { once: false, passive: true });
            }
        });
        
        console.log('‚úÖ Bot√µes interceptados com limpeza RIGOROSA');
    }, 2000);
}

/**
 * ATUALIZAR LISTA DE INGRESSOS AP√ìS EDI√á√ÉO
 */
async function atualizarListaAposEdicao() {
    console.log('üîÑ Atualizando lista de ingressos ap√≥s edi√ß√£o...');
    
    // Tentar usar fun√ß√µes existentes de recarregamento
    const funcoesRecarregamento = [
        'recarregarListaAPILimpa',
        'renderizarIngressosPersonalizado',
        'recarregarIngressosEtapa6',
        'carregarIngressos',
        'loadTickets',
        'refreshTicketList'
    ];
    
    let recarregouComSucesso = false;
    
    for (const nomeFuncao of funcoesRecarregamento) {
        if (typeof window[nomeFuncao] === 'function') {
            try {
                console.log(`üîÑ Tentando recarregar com ${nomeFuncao}...`);
                await window[nomeFuncao]();
                recarregouComSucesso = true;
                console.log(`‚úÖ Lista recarregada com ${nomeFuncao}`);
                break;
            } catch (error) {
                console.warn(`‚ö†Ô∏è Erro ao recarregar com ${nomeFuncao}:`, error);
            }
        }
    }
    
    if (!recarregouComSucesso) {
        console.log('‚ö†Ô∏è Nenhuma fun√ß√£o de recarregamento encontrada, usando m√©todo direto');
        await recarregarListaDiretamente();
    }
}

/**
 * RECARREGAR LISTA DIRETAMENTE
 */
async function recarregarListaDiretamente() {
    console.log('üîÑ Recarregando lista diretamente...');
    
    const eventoId = new URLSearchParams(window.location.search).get('evento_id');
    
    if (!eventoId) {
        console.log('üìù Novo evento - sem lista para recarregar');
        return;
    }
    
    try {
        const response = await fetch('/produtor/ajax/ingressos_api.php', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded',
            },
            body: `action=listar_ingressos&evento_id=${eventoId}`
        });
        
        const textResponse = await response.text();
        console.log('üì° Resposta lista direta:', textResponse.substring(0, 200) + '...');
        
        let data;
        try {
            data = JSON.parse(textResponse);
        } catch (parseError) {
            console.error('‚ùå Erro ao parsear JSON da lista:', parseError);
            return;
        }
        
        if (data.sucesso) {
            // Atualizar dados globais se existirem
            if (window.dadosAtivos) {
                window.dadosAtivos.ingressos = data.ingressos || [];
                console.log(`‚úÖ Dados globais atualizados: ${data.ingressos?.length || 0} ingressos`);
            }
            
            // Tentar renderizar usando fun√ß√£o dispon√≠vel
            if (typeof window.renderizarIngressosPersonalizado === 'function') {
                window.renderizarIngressosPersonalizado();
                console.log('‚úÖ Lista renderizada com fun√ß√£o personalizada');
            } else {
                console.log('‚ö†Ô∏è Fun√ß√£o de renderiza√ß√£o n√£o encontrada');
            }
            
        } else {
            console.error('‚ùå Erro ao recarregar lista:', data.erro);
        }
        
    } catch (error) {
        console.error('‚ùå Erro no recarregamento direto:', error);
    }
}

/**
 * INTERCEPTAR FUN√á√ïES DE UPDATE PARA ATUALIZAR LISTA
 */
function interceptarFuncoesUpdate() {
    console.log('üéØ Configurando intercepta√ß√£o de fun√ß√µes de update...');
    
    // Lista de fun√ß√µes que fazem update
    const funcoesUpdateOriginais = {};
    
    [
        'updatePaidTicket', 'updateFreeTicket', 'updateComboTicket',
        'salvarEdicaoIngresso', 'salvarIngressoEditado'
    ].forEach(nomeFuncao => {
        if (typeof window[nomeFuncao] === 'function') {
            funcoesUpdateOriginais[nomeFuncao] = window[nomeFuncao];
            
            window[nomeFuncao] = async function(...args) {
                console.log(`üéØ Interceptando ${nomeFuncao} para atualiza√ß√£o posterior`);
                
                // Executar fun√ß√£o original
                let resultado;
                try {
                    resultado = await funcoesUpdateOriginais[nomeFuncao].apply(this, args);
                } catch (error) {
                    resultado = funcoesUpdateOriginais[nomeFuncao].apply(this, args);
                }
                
                // Atualizar lista ap√≥s salvar
                setTimeout(() => {
                    console.log(`üîÑ Atualizando lista ap√≥s ${nomeFuncao}`);
                    atualizarListaAposEdicao();
                }, 500);
                
                return resultado;
            };
            
            console.log(`‚úÖ ${nomeFuncao} interceptada para atualiza√ß√£o`);
        }
    });
}

/**
 * FUN√á√ÉO GLOBAL PARA FOR√áAR LIMPEZA MANUAL - VERS√ÉO RIGOROSA
 */
window.forcarLimpezaCacheLotes = function() {
    console.log('üîß For√ßando limpeza RIGOROSA manual do cache de lotes...');
    
    // Resetar flag de carregamento
    window.carregandoLotes = false;
    
    // Limpeza rigorosa
    limparCacheSelectsLote();
    
    setTimeout(() => {
        if (!window.carregandoLotes) {
            carregarLotesLimpos();
        }
    }, 200);
    
    console.log('‚úÖ Limpeza rigorosa manual conclu√≠da');
};

/**
 * FUN√á√ÉO GLOBAL PARA DEBUG DOS SELECTS
 */
window.debugSelectsLotes = function() {
    console.log('üîç DEBUG dos selects de lotes:');
    
    const selectsLote = [
        'paidTicketLote', 'freeTicketLote', 'comboTicketLote',
        'editPaidTicketLote', 'editFreeTicketLote', 'editComboTicketLote'
    ];
    
    selectsLote.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            console.log(`  ${id}: ${select.options.length} op√ß√µes`);
            for (let i = 0; i < select.options.length; i++) {
                console.log(`    ${i}: "${select.options[i].text}" (value: ${select.options[i].value})`);
            }
            console.log(`    √öltimo carregamento: ${select.getAttribute('data-ultimo-carregamento') || 'nunca'}`);
        } else {
            console.log(`  ${id}: n√£o encontrado`);
        }
    });
    
    console.log(`  Carregando lotes: ${window.carregandoLotes || false}`);
};

/**
 * FUN√á√ÉO GLOBAL PARA RESET COMPLETO (EMERG√äNCIA)
 */
window.resetCompletoDosSelects = function() {
    console.log('üö® RESET COMPLETO DOS SELECTS - EMERG√äNCIA');
    
    // Parar qualquer carregamento
    window.carregandoLotes = false;
    
    // Limpar TUDO
    const selectsLote = [
        'paidTicketLote', 'freeTicketLote', 'comboTicketLote',
        'editPaidTicketLote', 'editFreeTicketLote', 'editComboTicketLote'
    ];
    
    selectsLote.forEach(id => {
        const select = document.getElementById(id);
        if (select) {
            // RESET TOTAL
            select.innerHTML = '<option value="">Selecione um lote</option>';
            select.removeAttribute('data-ultimo-carregamento');
            select.removeAttribute('data-cache-limpo');
            console.log(`üö® ${id} RESETADO completamente`);
        }
    });
    
    // Aguardar e recarregar
    setTimeout(() => {
        console.log('üîÑ Recarregando ap√≥s reset completo...');
        carregarLotesLimpos();
    }, 500);
    
    console.log('‚úÖ Reset completo conclu√≠do');
};

/**
 * FUN√á√ÉO GLOBAL PARA FOR√áAR ATUALIZA√á√ÉO MANUAL
 */
window.forcarAtualizacaoLista = function() {
    console.log('üîß For√ßando atualiza√ß√£o manual da lista...');
    atualizarListaAposEdicao();
};

/**
 * Inicializa√ß√£o
 */
function inicializar() {
    console.log('üöÄ Inicializando corre√ß√µes adicionais...');
    
    // CR√çTICO: Bloquear outras fun√ß√µes que carregam lotes
    setTimeout(() => {
        bloquearFuncoesCarregamentoLotes();
    }, 500);
    
    // Configurar intercepta√ß√µes
    setTimeout(() => {
        interceptarAberturaDosModais();
        interceptarFuncoesUpdate();
    }, 1000);
    
    // Limpeza inicial RIGOROSA
    setTimeout(() => {
        limparCacheSelectsLote();
        carregarLotesLimpos();
    }, 2000);
    
    console.log('‚úÖ Corre√ß√µes adicionais inicializadas com controle RIGOROSO');
}

// Auto-inicializar
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', inicializar);
} else {
    inicializar();
}

console.log('‚úÖ COMBO-CORRECOES-ADICIONAIS.JS carregado!');
console.log('üîß Corre√ß√µes RIGOROSAS implementadas:');
console.log('  1. ‚úÖ Limpeza TOTAL de cache dos selects de lote');
console.log('  2. ‚úÖ Carregamento √öNICO sem duplica√ß√£o');
console.log('  3. ‚úÖ Bloqueio de fun√ß√µes conflitantes');
console.log('  4. ‚úÖ Controle de timing para evitar sobreposi√ß√£o');
console.log('  5. ‚úÖ Atualiza√ß√£o autom√°tica da lista ap√≥s edi√ß√£o');
console.log('üí° Fun√ß√µes manuais RIGOROSAS:');
console.log('  - window.forcarLimpezaCacheLotes() - limpeza rigorosa manual');
console.log('  - window.debugSelectsLotes() - debug completo dos selects');
console.log('  - window.resetCompletoDosSelects() - RESET COMPLETO (emerg√™ncia)');
console.log('  - window.forcarAtualizacaoLista() - atualizar lista manualmente');
